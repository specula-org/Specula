"""Handler for clean_traces tool."""

import glob
import os
from typing import Dict, Any, List

from .base import BaseHandler
from ..utils.errors import ExecutionError


class CleanTracesHandler(BaseHandler):
    """Handler for clean_traces tool.

    Deletes TTrace output files (.tla/.bin) generated by validating a spec file.
    """

    @property
    def tool_name(self) -> str:
        return "clean_traces"

    @property
    def argument_schema(self) -> Dict[str, Any]:
        return {
            "type": "object",
            "properties": {
                "spec_file": {
                    "type": "string",
                    "description": "Path to the TLA+ spec file (e.g., Traceetcdraft.tla)"
                },
            },
            "required": ["spec_file"]
        }

    async def execute(self, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Delete TTrace output files for a spec file.

        Args:
            arguments: Validated arguments

        Raises:
            ExecutionError: If spec file is missing or file operations fail
        """
        spec_file = arguments["spec_file"]

        if not os.path.exists(spec_file):
            raise ExecutionError(
                f"Spec file not found: {spec_file}",
                details={"spec_file": spec_file, "exists": False}
            )

        if not os.path.isfile(spec_file):
            raise ExecutionError(
                f"Spec path is not a file: {spec_file}",
                details={"spec_file": spec_file, "is_file": False}
            )

        spec_dir = os.path.dirname(spec_file) or "."
        spec_basename = os.path.splitext(os.path.basename(spec_file))[0]

        pattern = os.path.join(spec_dir, f"{spec_basename}_TTrace_*")
        matched_files = sorted(glob.glob(pattern))

        for file_path in matched_files:
            try:
                os.remove(file_path)
            except OSError:
                pass

        return {}
