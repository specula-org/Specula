---- MODULE Raft ----
EXTENDS Naturals, Sequences, FiniteSets, TLC

CONSTANTS
    None,
    MaxLogLen,
    MaxTerm,
    Server,
    Nil

VARIABLES
    state,
    currentTerm,
    votedFor,
    log,
    commitIndex,
    leaderId,
    matchIndex,
    nextIndex,
    votesGranted,
    pendingConfIndex,
    uncommittedSize,
    leadTransferee,
    isLearner,
    electionElapsed,
    heartbeatElapsed,
    randomizedElectionTimeout,
    messages,
    pc,
    stack,
    info

\* Generated by SANY CFG Transformer
\* Original operators reconstructed from Control Flow Graph

vars ==
    << state , currentTerm , votedFor , log , commitIndex , leaderId , matchIndex , nextIndex , votesGranted , pendingConfIndex , uncommittedSize , leadTransferee , isLearner , electionElapsed , heartbeatElapsed , randomizedElectionTimeout , messages >>

MsgVote ==
    "MsgVote"

MsgVoteResp ==
    "MsgVoteResp"

MsgPreVote ==
    "MsgPreVote"

MsgPreVoteResp ==
    "MsgPreVoteResp"

MsgApp ==
    "MsgApp"

MsgAppResp ==
    "MsgAppResp"

MsgHeartbeat ==
    "MsgHeartbeat"

MsgHeartbeatResp ==
    "MsgHeartbeatResp"

MsgSnap ==
    "MsgSnap"

MsgTimeoutNow ==
    "MsgTimeoutNow"

MsgHup ==
    "MsgHup"

MsgBeat ==
    "MsgBeat"

MsgProp ==
    "MsgProp"

StateFollower ==
    "StateFollower"

StateCandidate ==
    "StateCandidate"

StateLeader ==
    "StateLeader"

StatePreCandidate ==
    "StatePreCandidate"

Min(a, b) ==
    IF a < b THEN a ELSE b

Max(a, b) ==
    IF a > b THEN a ELSE b

LastLogIndex(s) ==
    Len (log [s])

LastLogTerm(s) ==
    IF Len (log [s]) = 0 THEN 0 ELSE log [s] [Len (log [s])].term

IsLogUpToDate(s, lastLogTerm, lastLogIndex) ==
    \/ lastLogTerm > LastLogTerm (s) \/ /\ lastLogTerm = LastLogTerm (s) /\ lastLogIndex >= LastLogIndex (s)

CountVotes(s) ==
    Cardinality ({v \in Server : votesGranted [s] [v]})

BecomeFollower(s, term, leader) ==
    /\ state' = [state EXCEPT ![s] = StateFollower]
    /\ currentTerm' = [currentTerm EXCEPT ![s] = term]
    /\ votedFor' = [votedFor EXCEPT ![s] = IF term > currentTerm [s] THEN None ELSE votedFor [s]]
    /\ leaderId' = [leaderId EXCEPT ![s] = leader]
    /\ electionElapsed' = [electionElapsed EXCEPT ![s] = 0]
    /\ heartbeatElapsed' = [heartbeatElapsed EXCEPT ![s] = 0]
    /\ votesGranted' = [votesGranted EXCEPT ![s] = [t \in Server |-> FALSE]]
    /\ leadTransferee' = [leadTransferee EXCEPT ![s] = None]
    /\ uncommittedSize' = [uncommittedSize EXCEPT ![s] = 0]

BecomeCandidate(s) ==
    /\ state [s] # StateLeader
    /\ state' = [state EXCEPT ![s] = StateCandidate]
    /\ currentTerm' = [currentTerm EXCEPT ![s] = currentTerm [s] + 1]
    /\ votedFor' = [votedFor EXCEPT ![s] = s]
    /\ votesGranted' = [votesGranted EXCEPT ![s] = [t \in Server |-> IF t = s THEN TRUE ELSE FALSE]]
    /\ electionElapsed' = [electionElapsed EXCEPT ![s] = 0]
    /\ leaderId' = [leaderId EXCEPT ![s] = None]

BecomePreCandidate(s) ==
    /\ state [s] # StateLeader
    /\ state' = [state EXCEPT ![s] = StatePreCandidate]
    /\ votesGranted' = [votesGranted EXCEPT ![s] = [t \in Server |-> FALSE]]
    /\ electionElapsed' = [electionElapsed EXCEPT ![s] = 0]
    /\ leaderId' = [leaderId EXCEPT ![s] = None]

BecomeLeader(s) ==
    /\ state [s] # StateFollower
    /\ state' = [state EXCEPT ![s] = StateLeader]
    /\ leaderId' = [leaderId EXCEPT ![s] = s]
    /\ heartbeatElapsed' = [heartbeatElapsed EXCEPT ![s] = 0]
    /\ nextIndex' = [nextIndex EXCEPT ![s] = [t \in Server |-> LastLogIndex (s) + 1]]
    /\ matchIndex' = [matchIndex EXCEPT ![s] = [t \in Server |-> IF t = s THEN LastLogIndex (s) ELSE 0]]
    /\ pendingConfIndex' = [pendingConfIndex EXCEPT ![s] = LastLogIndex (s)]
    /\ log' = [log EXCEPT ![s] = Append (log [s] , [term |-> currentTerm [s] , data |-> << >>])]
    /\ messages' = messages \cup {[type |-> MsgAppResp , from |-> s , to |-> s , term |-> currentTerm [s] , index |-> LastLogIndex (s) + 1]}

Campaign(s, campaignType) ==
    /\ \/ /\ campaignType = "PreElection"
          /\ BecomePreCandidate (s)
          /\ LET term == currentTerm[s] + 1
              IN
              /\ messages' = messages \cup {[type |-> MsgPreVote , from |-> s , to |-> t , term |-> term , logTerm |-> LastLogTerm (s) , index |-> LastLogIndex (s)] : t \in Server \ {s}}
              /\ UNCHANGED <<votedFor, currentTerm>>
       \/ /\ campaignType = "Election"
          /\ BecomeCandidate (s)
          /\ messages' = messages \cup {[type |-> MsgVote , from |-> s , to |-> t , term |-> currentTerm' [s] , logTerm |-> LastLogTerm (s) , index |-> LastLogIndex (s)] : t \in Server \ {s}}

HandleVote(s, m) ==
    LET canVote == \/ votedFor[s] = m.from
                   \/ /\ votedFor[s] = None
                      /\ leaderId[s] = None
                   \/ /\ m.type = MsgPreVote
                      /\ m.term > currentTerm[s]
        IN
        /\ IF /\ canVote /\ IsLogUpToDate (s , m.logTerm , m.index) THEN
            /\ messages' = messages \cup {[type |-> IF m.type = MsgVote THEN MsgVoteResp ELSE MsgPreVoteResp , from |-> s , to |-> m.from , term |-> m.term]}
            /\ IF m.type = MsgVote THEN
                /\ votedFor' = [votedFor EXCEPT ![s] = m.from]
                /\ electionElapsed' = [electionElapsed EXCEPT ![s] = 0]
                ELSE
                /\ UNCHANGED <<votedFor, electionElapsed>>
            ELSE
            /\ messages' = messages \cup {[type |-> IF m.type = MsgVote THEN MsgVoteResp ELSE MsgPreVoteResp , from |-> s , to |-> m.from , term |-> currentTerm [s] , reject |-> TRUE]}
            /\ UNCHANGED <<votedFor, electionElapsed>>

MaybeCommit(s) ==
    /\ state [s] = StateLeader
    /\ LET newCommitIndex == CHOOSE i \in 1..Len(log[s]) :
           /\ i > commitIndex[s]
           /\ log[s][i].term = currentTerm[s]
           /\ Cardinality({t \in Server : matchIndex[s][t] >= i}) * 2 > Cardinality(Server)
           /\ \A j \in (i+1)..Len(log[s]) : 
              ~(/\ log[s][j].term = currentTerm[s]
                /\ Cardinality({t \in Server : matchIndex[s][t] >= j}) * 2 > Cardinality(Server))
        IN
        /\ commitIndex' = [commitIndex EXCEPT ![s] = newCommitIndex]

HandleAppResp(s, m) ==
    /\ IF m.reject THEN
        /\ nextIndex' = [nextIndex EXCEPT ![s] [m.from] = Max (1 , m.rejectHint)]
        /\ messages' = messages \cup {[type |-> MsgApp , from |-> s , to |-> m.from , term |-> currentTerm [s] , prevLogIndex |-> nextIndex' [s] [m.from] - 1 , prevLogTerm |-> IF nextIndex' [s] [m.from] > 1 THEN log [s] [nextIndex' [s] [m.from] - 1].term ELSE 0 , entries |-> SubSeq (log [s] , nextIndex' [s] [m.from] , Len (log [s])) , commit |-> commitIndex [s]]}
        /\ UNCHANGED <<matchIndex, commitIndex>>
        ELSE
        /\ matchIndex' = [matchIndex EXCEPT ![s] [m.from] = m.index]
        /\ nextIndex' = [nextIndex EXCEPT ![s] [m.from] = m.index + 1]
        /\ MaybeCommit (s)
        /\ UNCHANGED <<messages>>

HandleHeartbeat(s, m) ==
    /\ commitIndex' = [commitIndex EXCEPT ![s] = Max (commitIndex [s] , m.commit)]
    /\ messages' = messages \cup {[type |-> MsgHeartbeatResp , from |-> s , to |-> m.from , term |-> currentTerm [s]]}

HandleHeartbeatResp(s, m) ==
    /\ IF matchIndex [s] [m.from] < LastLogIndex (s) THEN
        /\ messages' = messages \cup {[type |-> MsgApp , from |-> s , to |-> m.from , term |-> currentTerm [s] , prevLogIndex |-> nextIndex [s] [m.from] - 1 , prevLogTerm |-> IF nextIndex [s] [m.from] > 1 THEN log [s] [nextIndex [s] [m.from] - 1].term ELSE 0 , entries |-> SubSeq (log [s] , nextIndex [s] [m.from] , Len (log [s])) , commit |-> commitIndex [s]]}
        ELSE
        /\ UNCHANGED <<messages>>

StepLeader(s, m) ==
    /\ \/ /\ m.type = MsgBeat
          /\ messages' = messages \cup {[type |-> MsgHeartbeat , from |-> s , to |-> t , term |-> currentTerm [s] , commit |-> Min (matchIndex [s] [t] , commitIndex [s])] : t \in Server \ {s}}
          /\ UNCHANGED <<log, matchIndex, nextIndex, commitIndex>>
       \/ /\ m.type = MsgProp
          /\ leadTransferee [s] = None
          /\ LET newEntry == [term |-> currentTerm[s], data |-> m.data]
                 newLog == Append(log[s], newEntry)
              IN
              /\ log' = [log EXCEPT ![s] = newLog]
              /\ messages' = messages \cup {[type |-> MsgApp , from |-> s , to |-> t , term |-> currentTerm [s] , prevLogIndex |-> nextIndex [s] [t] - 1 , prevLogTerm |-> IF nextIndex [s] [t] > 1 THEN log [s] [nextIndex [s] [t] - 1].term ELSE 0 , entries |-> << newEntry >> , commit |-> commitIndex [s]] : t \in Server \ {s}}
              /\ UNCHANGED <<matchIndex, nextIndex, commitIndex>>
       \/ /\ m.type = MsgAppResp
          /\ HandleAppResp (s , m)
          /\ UNCHANGED <<log>>
       \/ /\ m.type = MsgHeartbeatResp
          /\ HandleHeartbeatResp (s , m)
          /\ UNCHANGED <<log, matchIndex, nextIndex, commitIndex>>

Poll(s, from, msgType, granted) ==
    /\ votesGranted' = [votesGranted EXCEPT ![s] [from] = granted]
    /\ LET voteCount == CountVotes(s)
        IN
        /\ IF voteCount * 2 > Cardinality (Server) THEN
            /\ IF state [s] = StatePreCandidate THEN
                /\ pc' = "Poll_1"
                /\ info' = [temp |-> [voteCount |-> voteCount]] @@ info
                /\ stack' = Append(stack, [backsite |-> "Poll_1", args |-> << s , "Election">>, info |-> info'])
                /\ UNCHANGED <<log, heartbeatElapsed, messages, matchIndex, nextIndex, state, pendingConfIndex, leaderId>>
                ELSE
                /\ BecomeLeader (s)
                /\ pc' = stack[Len(stack)].backsite
                /\ stack' = Tail(stack)
                /\ info' = stack[Len(stack)].info
            ELSE
            /\ IF (Cardinality (Server) - voteCount) * 2 >= Cardinality (Server) THEN
                /\ pc' = "Poll_2"
                /\ info' = [temp |-> [voteCount |-> voteCount]] @@ info
                /\ stack' = Append(stack, [backsite |-> "Poll_2", args |-> << s , currentTerm [s] , None>>, info |-> info'])
                /\ UNCHANGED <<log, heartbeatElapsed, messages, matchIndex, nextIndex, state, pendingConfIndex, leaderId>>
                ELSE
                /\ pc' = stack[Len(stack)].backsite
                /\ stack' = Tail(stack)
                /\ info' = stack[Len(stack)].info
                /\ UNCHANGED <<log, heartbeatElapsed, messages, matchIndex, nextIndex, state, pendingConfIndex, leaderId>>

HandleVoteResp(s, m) ==
    /\ pc' = "Poll"
    /\ info' = info
    /\ stack' = Append(stack, [backsite |-> "HandleVoteResp_1", args |-> << s , m.from , m.type , ~ m.reject>>, info |-> info'])

StepCandidate(s, m) ==
    /\ \/ /\ m.type = MsgProp
          /\ UNCHANGED vars
          /\ pc' = stack[Len(stack)].backsite
          /\ stack' = Tail(stack)
          /\ info' = stack[Len(stack)].info
       \/ /\ m.type \in {MsgApp , MsgHeartbeat}
          /\ BecomeFollower (s , m.term , m.from)
          /\ pc' = stack[Len(stack)].backsite
          /\ stack' = Tail(stack)
          /\ info' = stack[Len(stack)].info
          /\ UNCHANGED <<randomizedElectionTimeout, log, nextIndex, matchIndex, messages, pendingConfIndex, commitIndex, isLearner>>
       \/ /\ m.type = IF state [s] = StatePreCandidate THEN MsgPreVoteResp ELSE MsgVoteResp
          /\ pc' = "HandleVoteResp"
          /\ info' = info
          /\ stack' = Append(stack, [backsite |-> "StepCandidate_1", args |-> << s , m>>, info |-> info'])
          /\ UNCHANGED <<votedFor, leadTransferee, randomizedElectionTimeout, log, nextIndex, leaderId, currentTerm, votesGranted, heartbeatElapsed, matchIndex, messages, electionElapsed, state, pendingConfIndex, commitIndex, uncommittedSize, isLearner>>

HandleAppendEntries(s, m) ==
    /\ IF m.prevLogIndex < commitIndex [s] THEN
        /\ messages' = messages \cup {[type |-> MsgAppResp , from |-> s , to |-> m.from , term |-> currentTerm [s] , index |-> commitIndex [s]]}
        /\ UNCHANGED <<log, commitIndex>>
        ELSE
        /\ IF /\ m.prevLogIndex = 0 \/ /\ m.prevLogIndex <= Len (log [s]) /\ log [s] [m.prevLogIndex].term = m.prevLogTerm THEN
            /\ log' = [log EXCEPT ![s] = SubSeq (log [s] , 1 , m.prevLogIndex) \o m.entries]
            /\ commitIndex' = [commitIndex EXCEPT ![s] = Min (m.commit , m.prevLogIndex + Len (m.entries))]
            /\ messages' = messages \cup {[type |-> MsgAppResp , from |-> s , to |-> m.from , term |-> currentTerm [s] , index |-> m.prevLogIndex + Len (m.entries)]}
            ELSE
            LET hintIndex == Min(m.prevLogIndex, Len(log[s]))
                hintTerm == IF hintIndex > 0 /\ hintIndex <= Len(log[s]) 
                            THEN log[s][hintIndex].term 
                            ELSE 0
                IN
                /\ messages' = messages \cup {[type |-> MsgAppResp , from |-> s , to |-> m.from , term |-> currentTerm [s] , index |-> m.prevLogIndex , reject |-> TRUE , rejectHint |-> hintIndex , logTerm |-> hintTerm]}
                /\ UNCHANGED <<log, commitIndex>>

StepFollower(s, m) ==
    /\ \/ /\ m.type = MsgProp
          /\ IF leaderId [s] # None THEN
              /\ messages' = messages \cup {[type |-> m.type , from |-> s , to |-> leaderId [s] , data |-> m.data]}
              /\ UNCHANGED <<votedFor, currentTerm, log, votesGranted, electionElapsed, state, commitIndex, leaderId>>
              ELSE
              /\ UNCHANGED <<votedFor, currentTerm, log, votesGranted, messages, electionElapsed, state, commitIndex, leaderId>>
       \/ /\ m.type = MsgApp
          /\ electionElapsed' = [electionElapsed EXCEPT ![s] = 0]
          /\ leaderId' = [leaderId EXCEPT ![s] = m.from]
          /\ HandleAppendEntries (s , m)
          /\ UNCHANGED <<votedFor, currentTerm, votesGranted, state>>
       \/ /\ m.type = MsgHeartbeat
          /\ electionElapsed' = [electionElapsed EXCEPT ![s] = 0]
          /\ leaderId' = [leaderId EXCEPT ![s] = m.from]
          /\ HandleHeartbeat (s , m)
          /\ UNCHANGED <<votedFor, currentTerm, log, votesGranted, state>>
       \/ /\ m.type = MsgTimeoutNow
          /\ Campaign (s , "Election")
          /\ UNCHANGED <<log, commitIndex>>

Step(s, m) ==
    /\ \/ /\ m.term > currentTerm [s]
          /\ m.type # MsgPreVote
          /\ IF m.type \in {MsgApp , MsgHeartbeat , MsgSnap} THEN
              /\ BecomeFollower (s , m.term , m.from)
              /\ UNCHANGED <<log, nextIndex, pc, messages, matchIndex, commitIndex>>
              ELSE
              /\ BecomeFollower (s , m.term , None)
              /\ UNCHANGED <<log, nextIndex, pc, messages, matchIndex, commitIndex>>
       \/ /\ m.term < currentTerm [s]
          /\ IF m.type \in {MsgHeartbeat , MsgApp} THEN
              /\ messages' = messages \cup {[type |-> MsgAppResp , from |-> s , to |-> m.from , term |-> currentTerm [s]]}
              /\ UNCHANGED <<votedFor, leadTransferee, log, nextIndex, leaderId, currentTerm, pc, votesGranted, heartbeatElapsed, matchIndex, electionElapsed, state, uncommittedSize, commitIndex>>
              ELSE
              /\ IF m.type = MsgPreVote THEN
                  /\ messages' = messages \cup {[type |-> MsgPreVoteResp , from |-> s , to |-> m.from , term |-> currentTerm [s] , reject |-> TRUE]}
                  /\ UNCHANGED <<votedFor, leadTransferee, log, nextIndex, leaderId, currentTerm, pc, votesGranted, heartbeatElapsed, matchIndex, electionElapsed, state, uncommittedSize, commitIndex>>
                  ELSE
                  /\ UNCHANGED <<votedFor, leadTransferee, log, nextIndex, leaderId, currentTerm, pc, votesGranted, heartbeatElapsed, messages, matchIndex, electionElapsed, state, uncommittedSize, commitIndex>>
       \/ /\ m.term = currentTerm [s]
          /\ \/ /\ m.type = MsgHup
                /\ Campaign (s , "Election")
                /\ UNCHANGED <<leadTransferee, log, nextIndex, pc, heartbeatElapsed, matchIndex, uncommittedSize, commitIndex>>
             \/ /\ m.type \in {MsgVote , MsgPreVote}
                /\ HandleVote (s , m)
                /\ UNCHANGED <<leadTransferee, log, nextIndex, leaderId, currentTerm, pc, votesGranted, heartbeatElapsed, matchIndex, state, uncommittedSize, commitIndex>>
             \/ /\ state [s] = StateLeader
                /\ StepLeader (s , m)
                /\ UNCHANGED <<votedFor, leadTransferee, leaderId, currentTerm, pc, votesGranted, heartbeatElapsed, electionElapsed, state, uncommittedSize>>
             \/ /\ state [s] \in {StateCandidate , StatePreCandidate}
                /\ pc' = "Step_push_1"
                /\ UNCHANGED <<votedFor, leadTransferee, log, nextIndex, leaderId, currentTerm, votesGranted, heartbeatElapsed, messages, matchIndex, electionElapsed, state, uncommittedSize, commitIndex>>
             \/ /\ state [s] = StateFollower
                /\ StepFollower (s , m)
                /\ UNCHANGED <<leadTransferee, nextIndex, pc, heartbeatElapsed, matchIndex, uncommittedSize>>

Poll_1(s, from, msgType, granted) ==
    /\ Campaign (s , "Election")
    /\ pc' = stack[Len(stack)].backsite
    /\ stack' = Tail(stack)
    /\ info' = stack[Len(stack)].info

Poll_2(s, from, msgType, granted) ==
    /\ BecomeFollower (s , currentTerm [s] , None)
    /\ pc' = stack[Len(stack)].backsite
    /\ stack' = Tail(stack)
    /\ info' = stack[Len(stack)].info

HandleVoteResp_1(s, m) ==
    /\ TRUE
    /\ pc' = stack[Len(stack)].backsite
    /\ stack' = Tail(stack)
    /\ info' = stack[Len(stack)].info

StepCandidate_1(s, m) ==
    /\ TRUE
    /\ pc' = stack[Len(stack)].backsite
    /\ stack' = Tail(stack)
    /\ info' = stack[Len(stack)].info

Step_1(s, m) ==
    /\ TRUE
    /\ pc' = stack[Len(stack)].backsite
    /\ stack' = Tail(stack)
    /\ info' = stack[Len(stack)].info

Step_push_1(s, m) ==
    /\ info' = [args |-> <<s, m>>, temp |-> <<>>]
    /\ stack' = Append(stack, [backsite |-> "Step_1", args |-> << s , m>>, info |-> info'])
    /\ pc' = "StepCandidate"

HandlePoll ==
    /\ pc = "Poll"
    /\ Poll(info.args[1], info.args[2], info.args[3], info.args[4])
    /\ UNCHANGED <<votedFor, leadTransferee, randomizedElectionTimeout, currentTerm, electionElapsed, commitIndex, uncommittedSize, isLearner>>

HandleHandleVoteResp ==
    /\ pc = "HandleVoteResp"
    /\ HandleVoteResp(info.args[1], info.args[2])
    /\ UNCHANGED <<votedFor, leadTransferee, randomizedElectionTimeout, log, nextIndex, leaderId, currentTerm, votesGranted, heartbeatElapsed, matchIndex, messages, electionElapsed, state, pendingConfIndex, commitIndex, uncommittedSize, isLearner>>

HandleStepCandidate ==
    /\ pc = "StepCandidate"
    /\ StepCandidate(info.args[1], info.args[2])
    /\ UNCHANGED <<>>

HandleStep(s, m) ==
    /\ pc = Nil
    /\ Step(s, m)
    /\ UNCHANGED <<stack, randomizedElectionTimeout, pendingConfIndex, isLearner, info>>
    /\ stack' = <<[backsite |-> Nil, info |-> [args |-> <<>>, temp |-> <<>>], args |-> <<>>]>>

HandlePoll_1 ==
    /\ pc = "Poll_1"
    /\ Poll_1(info.args[1], info.args[2], info.args[3], info.args[4])
    /\ UNCHANGED <<leadTransferee, randomizedElectionTimeout, log, nextIndex, heartbeatElapsed, matchIndex, pendingConfIndex, commitIndex, uncommittedSize, isLearner>>

HandlePoll_2 ==
    /\ pc = "Poll_2"
    /\ Poll_2(info.args[1], info.args[2], info.args[3], info.args[4])
    /\ UNCHANGED <<randomizedElectionTimeout, log, nextIndex, matchIndex, messages, pendingConfIndex, commitIndex, isLearner>>

HandleHandleVoteResp_1 ==
    /\ pc = "HandleVoteResp_1"
    /\ HandleVoteResp_1(info.args[1], info.args[2])
    /\ UNCHANGED <<votedFor, leadTransferee, randomizedElectionTimeout, log, nextIndex, leaderId, currentTerm, votesGranted, heartbeatElapsed, matchIndex, messages, electionElapsed, state, pendingConfIndex, commitIndex, uncommittedSize, isLearner>>

HandleStepCandidate_1 ==
    /\ pc = "StepCandidate_1"
    /\ StepCandidate_1(info.args[1], info.args[2])
    /\ UNCHANGED <<votedFor, leadTransferee, randomizedElectionTimeout, log, nextIndex, leaderId, currentTerm, votesGranted, heartbeatElapsed, matchIndex, messages, electionElapsed, state, pendingConfIndex, commitIndex, uncommittedSize, isLearner>>

HandleStep_1 ==
    /\ pc = "Step_1"
    /\ Step_1(info.args[1], info.args[2])
    /\ UNCHANGED <<votedFor, leadTransferee, randomizedElectionTimeout, log, nextIndex, leaderId, currentTerm, votesGranted, heartbeatElapsed, matchIndex, messages, electionElapsed, state, pendingConfIndex, commitIndex, uncommittedSize, isLearner>>

\* End of generated TLA+ specification

Next == 
    \/ \E s \in Server : 
        /\ electionElapsed[s] >= randomizedElectionTimeout[s]
        /\ HandleStep(s, [type |-> MsgHup, from |-> s, to |-> s, term |-> currentTerm[s]])
    \/ \E s \in Server :
        /\ state[s] = StateLeader
        /\ heartbeatElapsed[s] >= 1
        /\ messages' = messages \cup 
           {[type |-> MsgBeat, from |-> s, to |-> s, term |-> currentTerm[s]]}
        /\ heartbeatElapsed' = [heartbeatElapsed EXCEPT ![s] = 0]
        /\ UNCHANGED <<state, currentTerm, votedFor, log, commitIndex, leaderId,
                       matchIndex, nextIndex, votesGranted, pendingConfIndex,
                       uncommittedSize, leadTransferee, isLearner, electionElapsed,
                       randomizedElectionTimeout, pc, stack, info>>
    \/ \E m \in messages, s \in Server :
        /\ m.to = s
        /\ HandleStep(s, m)
    \/ \E s \in Server :
        /\ electionElapsed' = [electionElapsed EXCEPT ![s] = electionElapsed[s] + 1]
        /\ heartbeatElapsed' = [heartbeatElapsed EXCEPT ![s] = heartbeatElapsed[s] + 1]
        /\ UNCHANGED <<state, currentTerm, votedFor, log, commitIndex, leaderId,
                       matchIndex, nextIndex, votesGranted, pendingConfIndex,
                       uncommittedSize, leadTransferee, isLearner, randomizedElectionTimeout,
                       messages, pc, stack, info>>

Init == 
    /\ state = [s \in Server |-> StateFollower]
    /\ currentTerm = [s \in Server |-> 0]
    /\ votedFor = [s \in Server |-> None]
    /\ log = [s \in Server |-> <<>>]
    /\ commitIndex = [s \in Server |-> 0]
    /\ leaderId = [s \in Server |-> None]
    /\ matchIndex = [s \in Server |-> [t \in Server |-> 0]]
    /\ nextIndex = [s \in Server |-> [t \in Server |-> 1]]
    /\ votesGranted = [s \in Server |-> [t \in Server |-> FALSE]]
    /\ pendingConfIndex = [s \in Server |-> 0]
    /\ uncommittedSize = [s \in Server |-> 0]
    /\ leadTransferee = [s \in Server |-> None]
    /\ isLearner = [s \in Server |-> FALSE]
    /\ electionElapsed = [s \in Server |-> 0]
    /\ heartbeatElapsed = [s \in Server |-> 0]
    /\ randomizedElectionTimeout = [s \in Server |-> 10]
    /\ messages = {}
    /\ pc = Nil
    /\ stack = <<>>
    /\ info = [args |-> <<>>, temp |-> <<>>]

Spec == Init /\ [][Next]_<<vars, pc, stack, info>>

====
